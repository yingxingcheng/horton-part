<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>horton_part.lisa module &mdash; Horton-Part  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/override.css?v=064c4a14" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="horton_part.lisa_g module" href="horton_part.lisa_g.html" />
    <link rel="prev" title="horton_part.isa module" href="horton_part.isa.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Horton-Part
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#downloading-code">Downloading Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#id1">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#building-documentation">Building Documentation</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Quick Start</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/quick_start.html">From Command Line</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/quick_start.html#Step-1:-Generate-Molecular-Density-and-Grid">Step 1: Generate Molecular Density and Grid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/quick_start.html#Step-2:-Do-Partitioning">Step 2: Do Partitioning</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/setup.html">Prepare Molecular Density and Grid</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/isa.html">Iterative Stockholder Analysis (ISA) method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/gisa.html">Gaussian Iterative Stockholder Analysis (GISA) method</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/gisa.html#Quadprog-Solver">Quadprog Solver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/gisa.html#Using-API">Using API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/gisa.html#Customized-Implementation">Customized Implementation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/gisa.html#CVXOPT-Solver">CVXOPT Solver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/gisa.html#id1">Using API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/gisa.html#id2">Customized Implementation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/gisa.html#ECOS-Sovler">ECOS Sovler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/gisa.html#OSQP-Solver">OSQP Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/gisa.html#Customized-SLSQP-Solver">Customized SLSQP Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/gisa.html#Customized-Least-Square-Sovler">Customized Least-Square Sovler</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/mbis.html">Minimum Basis Iterative Stockholder (MBIS) scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/lisa.html">Local Linear Iterative Stockholder Analysis (L-ISA) schemes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/lisa.html#Non-linear-optimization-problem">Non-linear optimization problem</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/lisa.html#Convex-optimization-method">Convex optimization method</a></li>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/lisa.html#Trust-region-method">Trust-region method</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/lisa.html#Non-linear-equations-(fixed-point-equations)">Non-linear equations (fixed-point equations)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/lisa.html#Self-consistent-method">Self-consistent method</a></li>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/lisa.html#Direct-Inversion-in-Iterative-Space-(DIIS)">Direct Inversion in Iterative Space (DIIS)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/lisa.html#Newton-Method">Newton Method</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/lisa.html#Customized-Methods">Customized Methods</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/lisa_diis.html">New Direct Inversion in Iterative Space (DIIS)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/lisa_g.html">Global Linear Iterative Stockholder Analysis (GL-ISA) schemes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/lisa_g.html#Non-linear-optimization-problem">Non-linear optimization problem</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/lisa_g.html#Convex-optimization-method">Convex optimization method</a></li>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/lisa_g.html#Trust-region-method">Trust-region method</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/lisa_g.html#Non-linear-equations-(fixed-point-equations)">Non-linear equations (fixed-point equations)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/lisa_g.html#Self-consistent-method">Self-consistent method</a></li>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/lisa_g.html#Direct-Inversion-of-Iterative-Space-(DIIS)">Direct Inversion of Iterative Space (DIIS)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/hirshfeld.html">(Iterative) Hirshfeld method</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/hirshfeld.html#Hirshfeld-method">Hirshfeld method</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/hirshfeld.html#Iterative-Hirshfeld-method">Iterative Hirshfeld method</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/mulliken.html">Mulliken method</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">horton_part</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="horton_part.html">horton_part package</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="horton_part.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="horton_part.algo.html">horton_part.algo package</a></li>
<li class="toctree-l4"><a class="reference internal" href="horton_part.core.html">horton_part.core package</a></li>
<li class="toctree-l4"><a class="reference internal" href="horton_part.scripts.html">horton_part.scripts package</a></li>
</ul>
</li>
<li class="toctree-l3 current"><a class="reference internal" href="horton_part.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="horton_part.becke.html">horton_part.becke module</a></li>
<li class="toctree-l4"><a class="reference internal" href="horton_part.gisa.html">horton_part.gisa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="horton_part.hirshfeld.html">horton_part.hirshfeld module</a></li>
<li class="toctree-l4"><a class="reference internal" href="horton_part.hirshfeld_i.html">horton_part.hirshfeld_i module</a></li>
<li class="toctree-l4"><a class="reference internal" href="horton_part.isa.html">horton_part.isa module</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">horton_part.lisa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="horton_part.lisa_g.html">horton_part.lisa_g module</a></li>
<li class="toctree-l4"><a class="reference internal" href="horton_part.mbis.html">horton_part.mbis module</a></li>
<li class="toctree-l4"><a class="reference internal" href="horton_part.mulliken.html">horton_part.mulliken module</a></li>
<li class="toctree-l4"><a class="reference internal" href="horton_part.utils.html">horton_part.utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="horton_part.html#module-horton_part">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Horton-Part</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">horton_part</a></li>
          <li class="breadcrumb-item"><a href="horton_part.html">horton_part package</a></li>
      <li class="breadcrumb-item active">horton_part.lisa module</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/pyapi/horton_part.lisa.rst" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-horton_part.lisa">
<span id="horton-part-lisa-module"></span><h1>horton_part.lisa module<a class="headerlink" href="#module-horton_part.lisa" title="Link to this heading"></a></h1>
<p>Module for Linear Iterative Stockholder Analysis (L-ISA) partitioning scheme.</p>
<dl class="py class">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LinearISAWPart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numbers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pseudo_numbers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moldens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spindens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cvxopt'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gauss'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="horton_part.gisa.html#horton_part.gisa.GaussianISAWPart" title="horton_part.gisa.GaussianISAWPart"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianISAWPart</span></code></a></p>
<p>Implements the Linear Iterative Stockholder Analysis (L-ISA) partitioning scheme.</p>
<p>This class extends <code class="docutils literal notranslate"><span class="pre">GaussianISAWPart</span></code> and specializes in performing
electron density partitioning in molecules using various L-ISA schemes. L-ISA
is a method for dividing the electron density of a molecule into atomic
contributions. This class offers a variety of schemes for this
partitioning, both at local <a class="footnote-reference brackets" href="#id14" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> and global optimization levels.</p>
<p><strong>Optimization Problem Schemes</strong></p>
<ul class="simple">
<li><p>Convex optimization (<a href="#id2"><span class="problematic" id="id3">`</span></a>solver`=”cvxopt”)</p></li>
<li><dl class="simple">
<dt>Trust-region methods with constraints</dt><dd><ul>
<li><p>Implicit constraints (<a href="#id4"><span class="problematic" id="id5">`</span></a>solver`=”trust-constr-im”)</p></li>
<li><p>Explicit constraints (<a href="#id6"><span class="problematic" id="id7">`</span></a>solver`=”trust-constr-ex”)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Fixed-point methods</dt><dd><ul>
<li><p>Alternating/self-consistent method (<a href="#id8"><span class="problematic" id="id9">`</span></a>solver`=”sc”)</p></li>
<li><p>Direct Inversion of Iterative Space (DIIS) (<a href="#id10"><span class="problematic" id="id11">`</span></a>sovler`=”diis”)</p></li>
<li><p>Newton method (<a href="#id12"><span class="problematic" id="id13">`</span></a>solver`=”newton”)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="horton_part.lisa_g.html#module-horton_part.lisa_g" title="horton_part.lisa_g"><code class="xref py py-obj docutils literal notranslate"><span class="pre">horton_part.lisa_g</span></code></a></dt><dd><p>Global Linear approximation of ISA.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id14" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Benda R., et al. Multi-center decomposition of molecular densities: A mathematical perspective.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numbers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pseudo_numbers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moldens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spindens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inner_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cvxopt'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gauss'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.__init__" title="Link to this definition"></a></dt>
<dd><p>LISA initial function.</p>
<p><strong>Optional arguments:</strong> (that are not defined in <code class="docutils literal notranslate"><span class="pre">GaussianISAWPart</span></code>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>basis_func</strong> (<em>string</em><em>, </em><em>optional</em>) – The type of basis functions, and Gaussian is the default.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.bs_helper">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bs_helper</span></span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.bs_helper" title="Link to this definition"></a></dt>
<dd><p>A basis function helper.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.builtin_solvers">
<span class="sig-name descname"><span class="pre">builtin_solvers</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{'cdiis':</span> <span class="pre">&lt;function</span> <span class="pre">solver_cdiis&gt;,</span> <span class="pre">'cvxopt':</span> <span class="pre">&lt;function</span> <span class="pre">solver_cvxopt&gt;,</span> <span class="pre">'diis':</span> <span class="pre">&lt;function</span> <span class="pre">solver_diis&gt;,</span> <span class="pre">'m-newton':</span> <span class="pre">&lt;function</span> <span class="pre">solver_m_newton&gt;,</span> <span class="pre">'newton':</span> <span class="pre">&lt;function</span> <span class="pre">solver_newton&gt;,</span> <span class="pre">'quasi-newton':</span> <span class="pre">&lt;function</span> <span class="pre">solver_quasi_newton&gt;,</span> <span class="pre">'sc':</span> <span class="pre">&lt;function</span> <span class="pre">solver_sc&gt;,</span> <span class="pre">'sc-1-iter':</span> <span class="pre">&lt;function</span> <span class="pre">solver_sc_1_iter&gt;,</span> <span class="pre">'sc-plus-convex':</span> <span class="pre">&lt;function</span> <span class="pre">solver_sc_plus_cvxopt&gt;,</span> <span class="pre">'trust-region':</span> <span class="pre">&lt;function</span> <span class="pre">solver_trust_region&gt;}</span></em><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.builtin_solvers" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.cache">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cache</span></span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.cache" title="Link to this definition"></a></dt>
<dd><p>Cache.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.clear" title="Link to this definition"></a></dt>
<dd><p>Discard all cached results, e.g. because wfn changed</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.compute_change">
<span class="sig-name descname"><span class="pre">compute_change</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">propars1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propars2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.compute_change" title="Link to this definition"></a></dt>
<dd><p>Compute the difference between an old and a new proatoms</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.compute_pseudo_population">
<span class="sig-name descname"><span class="pre">compute_pseudo_population</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.compute_pseudo_population" title="Link to this definition"></a></dt>
<dd><p>Compute pseudo population</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.coordinates">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">coordinates</span></span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.coordinates" title="Link to this definition"></a></dt>
<dd><p>Atomic coordinates.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.do_all">
<span class="sig-name descname"><span class="pre">do_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.do_all" title="Link to this definition"></a></dt>
<dd><p>Computes all properties and return a list of their keys.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.do_charges">
<span class="sig-name descname"><span class="pre">do_charges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.do_charges" title="Link to this definition"></a></dt>
<dd><p>Compute atomic charges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.do_density_decomposition">
<span class="sig-name descname"><span class="pre">do_density_decomposition</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.do_density_decomposition" title="Link to this definition"></a></dt>
<dd><p>Compute density decomposition.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.do_moments">
<span class="sig-name descname"><span class="pre">do_moments</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.do_moments" title="Link to this definition"></a></dt>
<dd><p>Compute atomic multiple moments.</p>
<p>Calculates various types of multipoles, including Cartesian, Spherical, and Radial moments.
The order of the moments is determined by the <cite>lmax</cite> parameter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.do_partitioning">
<span class="sig-name descname"><span class="pre">do_partitioning</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.do_partitioning" title="Link to this definition"></a></dt>
<dd><p>Do partitioning</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.do_populations">
<span class="sig-name descname"><span class="pre">do_populations</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.do_populations" title="Link to this definition"></a></dt>
<dd><p>Compute atomic populations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.do_prosplines">
<span class="sig-name descname"><span class="pre">do_prosplines</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.do_prosplines" title="Link to this definition"></a></dt>
<dd><p>Do pro-atom splines</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.do_spin_charges">
<span class="sig-name descname"><span class="pre">do_spin_charges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.do_spin_charges" title="Link to this definition"></a></dt>
<dd><p>Compute atomic spin charges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.eval_proatom">
<span class="sig-name descname"><span class="pre">eval_proatom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.eval_proatom" title="Link to this definition"></a></dt>
<dd><p>Evaluate function on a local grid.</p>
<p>The size of the local grid is specified by the radius of the sphere where the local grid is considered.
For example, when the radius is <cite>np.inf</cite>, the grid corresponds to the whole molecular grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<em>int</em>) – The index of an atom in the molecule.</p></li>
<li><p><strong>output</strong> (<em>np.array</em>) – The size of <cite>output</cite> should be the same as the size of the local grid.</p></li>
<li><p><strong>grid</strong> (<em>np.array</em>) – The local grid.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.eval_spline">
<span class="sig-name descname"><span class="pre">eval_spline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spline</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'noname'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.eval_spline" title="Link to this definition"></a></dt>
<dd><p>Evaluate a given spline at radial distances from a specified atom center and store the results in the output array.</p>
<p>This method calculates the radial distances from the specified atom center to each point in the provided grid.
It then evaluates the provided spline function at these distances, storing the results in the given output array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<em>int</em>) – The index of the atom whose center is used for calculating radial distances.</p></li>
<li><p><strong>spline</strong> (<em>callable</em>) – The spline function to be evaluated. This should be a function that takes an array of radial distances
and returns the corresponding spline values.</p></li>
<li><p><strong>output</strong> (<em>1D ndarray</em>) – The array where the evaluated spline values will be stored. This array is modified in-place.</p></li>
<li><p><strong>grid</strong> (<em>Grid</em>) – An object representing the grid points. It should have an attribute <cite>points</cite> which is an array of
grid point coordinates.</p></li>
<li><p><strong>label</strong> (<em>str</em><em>, </em><em>optional</em>) – A label for identification purposes, defaults to “noname”.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method computes the Euclidean norm (radial distance) from the atom center, specified by <cite>index</cite>, to each
point in the grid. The spline function is then evaluated at these distances. The results are stored directly
in the <cite>output</cite> array, overwriting any existing data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.fix_proatom_rho">
<span class="sig-name descname"><span class="pre">fix_proatom_rho</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deriv</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.fix_proatom_rho" title="Link to this definition"></a></dt>
<dd><p>Check if the radial density for the proatom is correct and fix as needed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<em>int</em>) – The atom for which this proatom rho is created.</p></li>
<li><p><strong>rho</strong> (<em>1D np.ndarray</em>) – The radial density</p></li>
<li><p><strong>deriv</strong> (<em>int</em>) – the derivative of the radial density or None.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.get_grid">
<span class="sig-name descname"><span class="pre">get_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.get_grid" title="Link to this definition"></a></dt>
<dd><p>Return an integration grid</p>
<p><strong>Optional arguments:</strong></p>
<dl class="simple">
<dt>index</dt><dd><p>The index of the atom. If not given, a grid for the entire
system is returned. If self.local is False, a full system grid
is always returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.get_moldens">
<span class="sig-name descname"><span class="pre">get_moldens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.get_moldens" title="Link to this definition"></a></dt>
<dd><p>Retrieves the molecular electron density (moldens) on the atomic grid.</p>
<p>This method converts the molecular electron density to the atomic grid specified
by the index. If an output array is provided, the result is stored in that array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The index of the atom for which the electron density is required.
If None, electron density for all atoms is considered. Default is None.</p></li>
<li><p><strong>output</strong> (<em>np.ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – An optional array to store the resulting electron density.
If provided, the result is saved in this array. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The molecular electron density on the atomic grid.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.get_proatom_rho">
<span class="sig-name descname"><span class="pre">get_proatom_rho</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iatom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.get_proatom_rho" title="Link to this definition"></a></dt>
<dd><p>Get pro-atom density for atom <cite>iatom</cite>.</p>
<p>If <cite>propars</cite> is <cite>None</cite>, the cache values are used; otherwise, the <cite>propars</cite> are used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iatom</strong> (<em>int</em>) – The index of atom <cite>iatom</cite>.</p></li>
<li><p><strong>propars</strong> (<em>np.array</em>) – The pro-atom parameters.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.get_proatom_spline">
<span class="sig-name descname"><span class="pre">get_proatom_spline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.get_proatom_spline" title="Link to this definition"></a></dt>
<dd><p>Create and return a spline representation of the radial density for a given atomic index.</p>
<p>This method first retrieves the radial density and its derivatives for the specified atomic index.
It then ensures the correctness of these values and constructs a spline representation based
on the radial grid points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<em>int</em>) – The index of the atom for which the radial density spline is to be calculated.</p></li>
<li><p><strong>*args</strong> – Variable length argument list, used for passing non-keyworded arguments.</p></li>
<li><p><strong>**kwargs</strong> – Arbitrary keyword arguments, used for passing additional data.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A spline representation of the radial density. If derivatives are available,
a <cite>CubicHermiteSpline</cite> is returned. Otherwise, a <cite>CubicSpline</cite> is used.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>CubicSpline or CubicHermiteSpline</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method internally calls <cite>get_proatom_rho</cite> to obtain the radial density (<cite>rho</cite>) and its
derivatives (<cite>deriv</cite>), and <cite>fix_proatom_rho</cite> to validate and potentially correct these values.
It also uses <cite>get_rgrid</cite> to acquire the radial grid points (<cite>rgrid.points</cite>). The spline is
constructed with these grid points and density values, with the type of spline depending on
the availability of derivative information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.get_rgrid">
<span class="sig-name descname"><span class="pre">get_rgrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.get_rgrid" title="Link to this definition"></a></dt>
<dd><p>Load radial grid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.get_spindens">
<span class="sig-name descname"><span class="pre">get_spindens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.get_spindens" title="Link to this definition"></a></dt>
<dd><p>Retrieves the spin density (spindens) on the atomic grid.</p>
<p>This method converts the spin density to the atomic grid specified by the index.
If an output array is provided, the result is stored in that array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The index of the atom for which the spin density is required.
If None, spin density for all atoms is considered. Default is None.</p></li>
<li><p><strong>output</strong> (<em>np.ndarray</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – An optional array to store the resulting spin density.
If provided, the result is saved in this array. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The spin density on the atomic grid.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.grid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">grid</span></span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.grid" title="Link to this definition"></a></dt>
<dd><p>Molecular grid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.initial_local_grids">
<span class="sig-name descname"><span class="pre">initial_local_grids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.initial_local_grids" title="Link to this definition"></a></dt>
<dd><p>Compute local grids for each atom.</p>
<p>This method initializes local grid properties and calculates grids for each atom based on their coordinates and a specified radius.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.lmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">lmax</span></span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.lmax" title="Link to this definition"></a></dt>
<dd><p>The maximum angular momentum index for moment calculations.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.local">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">local</span></span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.local" title="Link to this definition"></a></dt>
<dd><p>Whether local grids are included.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'lisa'</span></em><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.natom">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">natom</span></span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.natom" title="Link to this definition"></a></dt>
<dd><p>The number of atoms in the molecule.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.nelec">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelec</span></span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.nelec" title="Link to this definition"></a></dt>
<dd><p>The number of electrons in the molecule.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.numbers">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">numbers</span></span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.numbers" title="Link to this definition"></a></dt>
<dd><p>Atomic numbers</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.pseudo_numbers">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pseudo_numbers</span></span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.pseudo_numbers" title="Link to this definition"></a></dt>
<dd><p>Atomic charges.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.radius_cutoff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">radius_cutoff</span></span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.radius_cutoff" title="Link to this definition"></a></dt>
<dd><p>Get the radius of the local grid sphere.</p>
<p>This property returns the radius of the sphere within which local grids are considered.
The local grid radius is used in [global methods]. It’s a key parameter in [some process].</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The radius of the local grid sphere.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the local grid radius is not set or out of an expected range.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.to_atomic_grid">
<span class="sig-name descname"><span class="pre">to_atomic_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.to_atomic_grid" title="Link to this definition"></a></dt>
<dd><p>Load atomic contribution of molecular properties.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.update_at_weights">
<span class="sig-name descname"><span class="pre">update_at_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.update_at_weights" title="Link to this definition"></a></dt>
<dd><p>See <code class="docutils literal notranslate"><span class="pre">Part.update_at_weights</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="horton_part.lisa.LinearISAWPart.update_pro">
<span class="sig-name descname"><span class="pre">update_pro</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proatdens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">promoldens</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.LinearISAWPart.update_pro" title="Link to this definition"></a></dt>
<dd><p>Update the pro-molecule density arrays based on the pro-atom density for a specified atom index.</p>
<p>This method evaluates the pro-atom density for the specified atom index over either a local grid
(if defined) or the global grid. The evaluated density is then used to update the pro-molecule
density array. This process contributes to constructing the complete pro-molecule density profile
by accumulating contributions from individual atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<em>int</em>) – The index of the atom for which the pro-atom and pro-molecule densities are to be updated.</p></li>
<li><p><strong>proatdens</strong> (<em>1D np.ndarray</em>) – The array representing the pro-atom density. This array is updated with the new density values
for the specified atom.</p></li>
<li><p><strong>promoldens</strong> (<em>1D np.ndarray</em>) – The array representing the pro-molecule density. This array accumulates the density contributions
from each atom, including the one specified by <cite>index</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method checks if <cite>local_grids</cite> attribute is available. If so, it uses the local grid specific
to the atom index for density evaluation. Otherwise, it defaults to using the global grid.</p>
<p>The <cite>eval_proatom</cite> method is used to evaluate the pro-atom density, which is then used to update
the <cite>proatdens</cite> and <cite>promoldens</cite> arrays. A small constant (1e-100) is added to <cite>promoldens</cite> to avoid
zero values, especially important for iterative methods requiring non-zero initial values.</p>
<p>If <cite>local_grids</cite> is not present, the method employs the global grid for density evaluation and updates
the <cite>proatdens</cite> array using the <cite>to_atomic_grid</cite> method.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="horton_part.lisa.setup_bs_helper">
<span class="sig-name descname"><span class="pre">setup_bs_helper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">part</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.setup_bs_helper" title="Link to this definition"></a></dt>
<dd><p>Setup basis function helper.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="horton_part.lisa.solver_cdiis">
<span class="sig-name descname"><span class="pre">solver_cdiis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bs_funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">cdiis_options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.solver_cdiis" title="Link to this definition"></a></dt>
<dd><p>Optimize parameters for proatom density functions using CDIIS algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bs_funcs</strong> (<em>2D np.ndarray</em>) – Basis functions array with shape (M, N), where ‘M’ is the number of basis functions
and ‘N’ is the number of grid points.</p></li>
<li><p><strong>rho</strong> (<em>1D np.ndarray</em>) – Spherically-averaged atomic density as a function of radial distance, with shape (N,).</p></li>
<li><p><strong>propars</strong> (<em>1D np.ndarray</em>) – Pro-atom parameters with shape (M). ‘M’ is the number of basis functions.</p></li>
<li><p><strong>points</strong> (<em>1D np.ndarray</em>) – Radial coordinates of grid points, with shape (N,).</p></li>
<li><p><strong>weights</strong> (<em>1D np.ndarray</em>) – Weights for integration, including the angular part (4πr²), with shape (N,).</p></li>
<li><p><strong>threshold</strong> (<em>float</em><em>, </em><em>optional</em>) – default value : 1e-08
tolerence parameter for convergence test on residual (commutator)</p></li>
<li><p><strong>density_cutoff</strong> (<em>float</em>) – Density values below this cutoff are considered invalid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>conv</strong> – if convergence, True, else, False</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="horton_part.lisa.solver_cvxopt">
<span class="sig-name descname"><span class="pre">solver_cvxopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bs_funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_neg_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">cvxopt_options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.solver_cvxopt" title="Link to this definition"></a></dt>
<dd><p>Optimize parameters for pro-atom density functions using convex optimization method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bs_funcs</strong> (<em>2D np.ndarray</em>) – Basis functions array with shape (M, N), where ‘M’ is the number of basis functions
and ‘N’ is the number of grid points.</p></li>
<li><p><strong>rho</strong> (<em>1D np.ndarray</em>) – Spherically-averaged atomic density as a function of radial distance, with shape (N,).</p></li>
<li><p><strong>propars</strong> (<em>1D np.ndarray</em>) – Pro-atom parameters with shape (M). ‘M’ is the number of basis functions.</p></li>
<li><p><strong>points</strong> (<em>1D np.ndarray</em>) – Radial coordinates of grid points, with shape (N,).</p></li>
<li><p><strong>weights</strong> (<em>1D np.ndarray</em>) – Weights for integration, including the angular part (4πr²), with shape (N,).</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – Convergence threshold for the iterative process.</p></li>
<li><p><strong>density_cutoff</strong> (<em>float</em>) – Density values below this cutoff are considered invalid.</p></li>
<li><p><strong>allow_neg_params</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Whether negative parameters are allowed. The default is <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Optimized proatom parameters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>1D np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If the inner iteration does not converge.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="horton_part.lisa.solver_diis">
<span class="sig-name descname"><span class="pre">solver_diis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bs_funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">diis_options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.solver_diis" title="Link to this definition"></a></dt>
<dd><p>Optimize parameters for proatom density functions using direct inversion in an iterative space (DIIS).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bs_funcs</strong> (<em>2D np.ndarray</em>) – Basis functions array with shape (M, N), where ‘M’ is the number of basis functions
and ‘N’ is the number of grid points.</p></li>
<li><p><strong>rho</strong> (<em>1D np.ndarray</em>) – Spherically-averaged atomic density as a function of radial distance, with shape (N,).</p></li>
<li><p><strong>propars</strong> (<em>1D np.ndarray</em>) – Pro-atom parameters with shape (M). ‘M’ is the number of basis functions.</p></li>
<li><p><strong>points</strong> (<em>1D np.ndarray</em>) – Radial coordinates of grid points, with shape (N,).</p></li>
<li><p><strong>weights</strong> (<em>1D np.ndarray</em>) – Weights for integration, including the angular part (4πr²), with shape (N,).</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – Convergence threshold for the iterative process.</p></li>
<li><p><strong>density_cutoff</strong> (<em>float</em>) – Density values below this cutoff are considered invalid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Optimized proatom parameters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>1D np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If the inner iteration does not converge.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="horton_part.lisa.solver_m_newton">
<span class="sig-name descname"><span class="pre">solver_m_newton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bs_funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">newton_options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.solver_m_newton" title="Link to this definition"></a></dt>
<dd><p>Optimize parameters for pro-atom density functions using Newton method</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bs_funcs</strong> (<em>2D np.ndarray</em>) – Basis functions array with shape (M, N), where ‘M’ is the number of basis functions
and ‘N’ is the number of grid points.</p></li>
<li><p><strong>rho</strong> (<em>1D np.ndarray</em>) – Spherically-averaged atomic density as a function of radial distance, with shape (N,).</p></li>
<li><p><strong>propars</strong> (<em>1D np.ndarray</em>) – Pro-atom parameters with shape (M). ‘M’ is the number of basis functions.</p></li>
<li><p><strong>points</strong> (<em>1D np.ndarray</em>) – Radial coordinates of grid points, with shape (N,).</p></li>
<li><p><strong>weights</strong> (<em>1D np.ndarray</em>) – Weights for integration, including the angular part (4πr²), with shape (N,).</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – Convergence threshold for the iterative process.</p></li>
<li><p><strong>density_cutoff</strong> (<em>float</em>) – Density values below this cutoff are considered invalid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Optimized proatom parameters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>1D np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If the inner iteration does not converge.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="horton_part.lisa.solver_newton">
<span class="sig-name descname"><span class="pre">solver_newton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bs_funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">newton_options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.solver_newton" title="Link to this definition"></a></dt>
<dd><p>Optimize parameters for pro-atom density functions using Newton method</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bs_funcs</strong> (<em>2D np.ndarray</em>) – Basis functions array with shape (M, N), where ‘M’ is the number of basis functions
and ‘N’ is the number of grid points.</p></li>
<li><p><strong>rho</strong> (<em>1D np.ndarray</em>) – Spherically-averaged atomic density as a function of radial distance, with shape (N,).</p></li>
<li><p><strong>propars</strong> (<em>1D np.ndarray</em>) – Pro-atom parameters with shape (M). ‘M’ is the number of basis functions.</p></li>
<li><p><strong>points</strong> (<em>1D np.ndarray</em>) – Radial coordinates of grid points, with shape (N,).</p></li>
<li><p><strong>weights</strong> (<em>1D np.ndarray</em>) – Weights for integration, including the angular part (4πr²), with shape (N,).</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – Convergence threshold for the iterative process.</p></li>
<li><p><strong>density_cutoff</strong> (<em>float</em>) – Density values below this cutoff are considered invalid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Optimized proatom parameters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>1D np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If the inner iteration does not converge.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="horton_part.lisa.solver_quasi_newton">
<span class="sig-name descname"><span class="pre">solver_quasi_newton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bs_funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">newton_options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.solver_quasi_newton" title="Link to this definition"></a></dt>
<dd><p>Optimize parameters for pro-atom density functions using Quasi-Newton method</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bs_funcs</strong> (<em>2D np.ndarray</em>) – Basis functions array with shape (M, N), where ‘M’ is the number of basis functions
and ‘N’ is the number of grid points.</p></li>
<li><p><strong>rho</strong> (<em>1D np.ndarray</em>) – Spherically-averaged atomic density as a function of radial distance, with shape (N,).</p></li>
<li><p><strong>propars</strong> (<em>1D np.ndarray</em>) – Pro-atom parameters with shape (M). ‘M’ is the number of basis functions.</p></li>
<li><p><strong>points</strong> (<em>1D np.ndarray</em>) – Radial coordinates of grid points, with shape (N,).</p></li>
<li><p><strong>weights</strong> (<em>1D np.ndarray</em>) – Weights for integration, including the angular part (4πr²), with shape (N,).</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – Convergence threshold for the iterative process.</p></li>
<li><p><strong>density_cutoff</strong> (<em>float</em>) – Density values below this cutoff are considered invalid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Optimized proatom parameters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>1D np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If the inner iteration does not converge.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="horton_part.lisa.solver_sc">
<span class="sig-name descname"><span class="pre">solver_sc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bs_funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.solver_sc" title="Link to this definition"></a></dt>
<dd><p>Optimize parameters for proatom density functions using a self-consistent (SC) method.</p>
<p>This approach analytically computes the parameters, aiming to yield results comparable to
those obtained via L-ISA algorithms, which require non-negative parameters.</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[N_{Ai} = \int \rho_A(r) \frac{\rho_{Ai}^0(r)}{\rho_A^0(r)} dr\]</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bs_funcs</strong> (<em>2D np.ndarray</em>) – Basis functions array with shape (M, N), where ‘M’ is the number of basis functions
and ‘N’ is the number of grid points.</p></li>
<li><p><strong>rho</strong> (<em>1D np.ndarray</em>) – Spherically-averaged atomic density as a function of radial distance, with shape (N,).</p></li>
<li><p><strong>propars</strong> (<em>1D np.ndarray</em>) – Pro-atom parameters with shape (M). ‘M’ is the number of basis functions.</p></li>
<li><p><strong>points</strong> (<em>1D np.ndarray</em>) – Radial coordinates of grid points, with shape (N,).</p></li>
<li><p><strong>weights</strong> (<em>1D np.ndarray</em>) – Weights for integration, including the angular part (4πr²), with shape (N,).</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – Convergence threshold for the iterative process.</p></li>
<li><p><strong>density_cutoff</strong> (<em>float</em>) – Density values below this cutoff are considered invalid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Optimized proatom parameters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>1D np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If the inner iteration does not converge.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method iteratively optimizes the proatom density function parameters.
In each iteration, the basis functions and current parameters are used to compute
updated parameters, assessing convergence against the specified threshold.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="horton_part.lisa.solver_sc_1_iter">
<span class="sig-name descname"><span class="pre">solver_sc_1_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bs_funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.solver_sc_1_iter" title="Link to this definition"></a></dt>
<dd><p>Optimize parameters for proatom density functions using a self-consistent (SC) method.</p>
<div class="math notranslate nohighlight">
\[N_{Ai} = \int \rho_A(r) \frac{\rho_{Ai}^0(r)}{\rho_A^0(r)} dr\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bs_funcs</strong> (<em>2D np.ndarray</em>) – Basis functions array with shape (M, N), where ‘M’ is the number of basis functions
and ‘N’ is the number of grid points.</p></li>
<li><p><strong>rho</strong> (<em>1D np.ndarray</em>) – Spherically-averaged atomic density as a function of radial distance, with shape (N,).</p></li>
<li><p><strong>propars</strong> (<em>1D np.ndarray</em>) – Pro-atom parameters with shape (M). ‘M’ is the number of basis functions.</p></li>
<li><p><strong>points</strong> (<em>1D np.ndarray</em>) – Radial coordinates of grid points, with shape (N,).</p></li>
<li><p><strong>weights</strong> (<em>1D np.ndarray</em>) – Weights for integration, including the angular part (4πr²), with shape (N,).</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – Convergence threshold for the iterative process.</p></li>
<li><p><strong>density_cutoff</strong> (<em>float</em>) – Density values below this cutoff are considered invalid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Optimized proatom parameters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>1D np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If the inner iteration does not converge.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="horton_part.lisa.solver_sc_plus_cvxopt">
<span class="sig-name descname"><span class="pre">solver_sc_plus_cvxopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bs_funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc_iter_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.solver_sc_plus_cvxopt" title="Link to this definition"></a></dt>
<dd><p>Optimize parameters for proatom density functions using a mixing of self-consistent (SC) method and convex
optimization method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bs_funcs</strong> (<em>2D np.ndarray</em>) – Basis functions array with shape (M, N), where ‘M’ is the number of basis functions
and ‘N’ is the number of grid points.</p></li>
<li><p><strong>rho</strong> (<em>1D np.ndarray</em>) – Spherically-averaged atomic density as a function of radial distance, with shape (N,).</p></li>
<li><p><strong>propars</strong> (<em>1D np.ndarray</em>) – Pro-atom parameters with shape (M). ‘M’ is the number of basis functions.</p></li>
<li><p><strong>points</strong> (<em>1D np.ndarray</em>) – Radial coordinates of grid points, with shape (N,).</p></li>
<li><p><strong>weights</strong> (<em>1D np.ndarray</em>) – Weights for integration, including the angular part (4πr²), with shape (N,).</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – Convergence threshold for the iterative process.</p></li>
<li><p><strong>density_cutoff</strong> (<em>float</em>) – Density values below this cutoff are considered invalid.</p></li>
<li><p><strong>sc_iter_limit</strong> (<em>int</em>) – The number of iteration steps of self-consistent method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Optimized proatom parameters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>1D np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If the inner iteration does not converge.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="horton_part.lisa.solver_trust_region">
<span class="sig-name descname"><span class="pre">solver_trust_region</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bs_funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">propars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explicit_constr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#horton_part.lisa.solver_trust_region" title="Link to this definition"></a></dt>
<dd><p>Optimize parameters for pro-atom density functions using trust-region method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bs_funcs</strong> (<em>2D np.ndarray</em>) – Basis functions array with shape (M, N), where ‘M’ is the number of basis functions
and ‘N’ is the number of grid points.</p></li>
<li><p><strong>rho</strong> (<em>1D np.ndarray</em>) – Spherically-averaged atomic density as a function of radial distance, with shape (N,).</p></li>
<li><p><strong>propars</strong> (<em>1D np.ndarray</em>) – Pro-atom parameters with shape (M). ‘M’ is the number of basis functions.</p></li>
<li><p><strong>points</strong> (<em>1D np.ndarray</em>) – Radial coordinates of grid points, with shape (N,).</p></li>
<li><p><strong>weights</strong> (<em>1D np.ndarray</em>) – Weights for integration, including the angular part (4πr²), with shape (N,).</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – Convergence threshold for the iterative process.</p></li>
<li><p><strong>density_cutoff</strong> (<em>float</em>) – Density values below this cutoff are considered invalid.</p></li>
<li><p><strong>explicit_constr</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Whether adding an explicit constraint for the atomic population. The default is <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Optimized proatom parameters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>1D np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If the inner iteration does not converge.</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="horton_part.isa.html" class="btn btn-neutral float-left" title="horton_part.isa module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="horton_part.lisa_g.html" class="btn btn-neutral float-right" title="horton_part.lisa_g module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, YingXing Cheng.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>